---
slug: /spring-specification
title: Filtrer ses résults avec Spring
authors: nvh
tags: [ Java, Spring, langage, développement, tuto ]
draft: true # enlever ou mettre à false pour publier
enableComments: false # pour giscus
---
[spring-paging]: ../2024/2024-05-09.spring_paging.md

Dans un [article précédent][spring-paging], je t'ai montré comme tu pouvais paginer tes résultats avec Spring. Et je t'avais dit que j'allais te montrer comment les filtrer grâce aux Specifications. 

<!--truncate-->

## Que sont les Specifications ?

Les Specifications permettent de créer des requêtes programmatiquement. Ces requêtes peuvent être aussi complexes que des requêtes SQL, mais elles sont écrites en Java. Cela permet d'insérer une logique métier dans les requêtes.

Reprenons notre exemple de sac magique qui contient tout et surtout n'importe quoi. Nous allons va ajouter quelques propriétés à nos trucs, afin que cela soit plus parlant : un nombre de trucs, une date de mise en sac et un booléen pour dire si on aime ou pas le truc.

```java title="SomethingEntity.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.time.Instant;

@Entity // indique que cette classe est une entité JPA, c'est obligatoire pour que JPA puisse la gérer
@Getter // Lombok : génère automatiquement les getters
@Setter // Lombok : génère automatiquement les setters
@ToString // Lombok : génère automatiquement la méthode toString
public class SomethingEntity {

  @Id // indique que ce champ est la clé primaire qui identifie de manière unique chaque ligne en base
  @GeneratedValue(strategy = GenerationType.IDENTITY) // indique que c'est le SGBD qui s'occupe de générer les identifiants
  private Long id;
  private String name;
  private String description;
  private int quantity;
  @Setter(lombok.AccessLevel.NONE) // indique à Lombok de ne pas générer de setter pour ce champ
  @Column(updatable = false) // indique que la date d'insertion ne peut pas être modifiée
  private Instant insertionDate = Instant.now(); // la date d'insertion est initialisée à la date et l'heure actuelles
  private Boolean liked; // true si on aime, false si on n'aime pas, null si on n'a pas d'avis
}
```

Et le DTO associé, pour que tu puisses l'utiliser dans tes contrôleurs.

```java title="SomethingDTO.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.time.Instant;

@Getter // Lombok : génère automatiquement les getters
@Setter // Lombok : génère automatiquement les setters
@ToString // Lombok : génère automatiquement la méthode toString
public class SomethingDto {

  private Long id;
  private String name;
  private String description;
  private int quantity;
  private Instant insertionDate;
  private Boolean liked;
}
```

## Préparons les données

Pour pouvoir tester les Specifications, il faut des données. On va donc créer un component juste pour ça, qu'on lancera au démarrage de l'appli. J'ai supprimé les exemples précédents pour une meilleure lisibilité.
```java title="BeginSpringApplication.java"
package fr.nvh.begin.spring;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ConfigurableApplicationContext;

@SpringBootApplication
public class BeginSpringApplication {

  public static void main(String[] args) {
    ConfigurableApplicationContext context = SpringApplication.run(BeginSpringApplication.class, args);

    TestSpecification testSpecification = context.getBean(TestSpecification.class); // on récupère le Bean TestSpecification 
    testSpecification.init(); // on initialise les données
  }
}

```

Le composant qui va nous permettre de tester tout ça, pour voir si ça marche bien.

```java title="TestSpecification.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.stream.IntStream;

@Component
@Slf4j // Utilisation de Lombok pour générer les logs
@RequiredArgsConstructor
public class TestSpecification {

  private final DataGenerator dataGenerator;
  private final SomethingRepository repository;

  /**
   * Initialisation de la base de données.
   */
  public void init() {
    log.debug("*** Test de la spécification ***");
    repository.deleteAll(); // on vide la table pour être tranquille, surtout si tu as encore les anciens tests

    //création de 100 choses
    IntStream.range(0, 100)
            .mapToObj(i -> buildSomethingEntity())
            .forEach(repository::save);
  }

  /**
   * Création d'une instance de SomethingEntity.
   */
  private SomethingEntity buildSomethingEntity() {
    SomethingEntity something = new SomethingEntity();
    something.setName(dataGenerator.generateRandomText(10));
    something.setDescription(dataGenerator.generateRandomText(20));
    something.setLiked(dataGenerator.generateRandomBoolean());
    something.setQuantity(dataGenerator.generateRandomInt(10));
    return something;
  }
}

```

Et la petite classe utilitaire pour générer des données aléatoires.

```java title="DataGenerator.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import lombok.NoArgsConstructor;
import org.springframework.stereotype.Component;

import java.util.Random;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

@Component // pour que Spring puisse instancier cette classe
@NoArgsConstructor // pour que Lombok génère un constructeur sans argument
class DataGenerator {
  /**
   * Un générateur de données aléatoires. <br>
   * Il est initialisé avec une seed pour avoir toujours les mêmes valeurs aléatoires à chaque lancement.
   *
   */
  private static final Random RANDOM = new Random(2018080120180804L); // seed pour avoir toujours les mêmes valeurs aléatoires à chaque lancement.

  /**
   * Génère une chaîne de caractères aléatoires entre 'a' et 'z' de longueur donnée.
   */
  String generateRandomText(int length) {
    return IntStream.range(0, length)
            .map(i -> RANDOM.nextInt(26) + 'a')
            .mapToObj(Character::toString)
            .collect(Collectors.joining());
  }

  /**
   * Génère un booléen aléatoire. <br>
   * La methode {@link Random#nextBoolean()} génère seulement un boolean primitif et nous voulons un objet.
   */
  Boolean generateRandomBoolean() {
    return switch (RANDOM.nextInt(3)) {
      case 0 -> Boolean.FALSE;
      case 1 -> Boolean.TRUE;
      default -> null;
    };
  }

  /**
   * Génère un entier aléatoire entre 0 et max (exclus).
   */
  int generateRandomInt(int max) {
    return RANDOM.nextInt(max);
  }
}
```
:::info L'astuce de ton dev sensei

N'oublie pas de tester ce que tu viens de coder avant d'aller plus loin. Il vaut mieux tester au fur et à mesure. Tu trouveras plus facilement ton bug si tu viens d'écrire 2 lignes que 20 classes.

:::

## Préparons le repository

Ton `Repository` ne sait pas encore gérer les Specifications. Il va falloir lui dire qu'il peut les utiliser. Pour cela, tu vas simplement ajouter une... interface à ton `Repository`. Et non, ce n'est pas une annotation pour une fois. C'est l'interface `org.springframework.data.jpa.repository.JpaSpecificationExecutor`

```java title="SomethingRepository.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.JpaSpecificationExecutor;
import org.springframework.stereotype.Repository;

@Repository
// indique que cette interface est un bean Spring de type Repository, facultatif mais recommandé pour la clarté
public interface SomethingRepository
        extends JpaRepository<SomethingEntity, Long>, // interface Spring Data JPA qui fournit des méthodes pour effectuer des opérations CRUD sur l'entité
        JpaSpecificationExecutor<SomethingEntity>// interface Spring Data JPA qui fournit des méthodes pour effectuer des requêtes dynamiques avec des spécifications
{
}
```

Et c'est tout. Tu n'as rien d'autre à faire pour que ton `Repository` puisse gérer les Specifications. Tu as maintenant une dizaine de méthodes de plus dans ton repository, et elles prennent toutes une `Specification` en paramètre. Je te les présente rapidement, mais prends le temps de lire la [documentation](https://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaSpecificationExecutor.html) pour en savoir plus.
- `count(Specification<T> spec)` : retourne le nombre d'éléments qui correspondent à ta Specification.
- `delete(Specification<T> spec)` : supprime tous les éléments qui correspondent à ta Specification.
- `exists(Specification<T> spec)` : retourne `true` si au moins un élément correspond à ta Specification.
- `findAll(Specification<T> spec)` : la plus simple, elle retourne tous les éléments qui correspondent à ta Specification.
- `findAll(Specification<T> spec, Pageable pageable)` : retourne une page d'éléments qui correspondent à ta Specification. Si tu veux en savoir plus sur la pagination, lis l'[article que j'ai écrit dessus][spring-paging].
- `findAll(Specification<T> spec, Sort sort)` : retourne tous les éléments qui correspondent à ta Specification, triés selon le `Sort`.
- `findOne(Specification<T> spec)` : retourne l'élément s'il existe, et lève une exception s'il y en a plus d'un.
-`findBy(Specification<T> spec, Function<FluentQuery.FetchableFluentQuery<S>,R> queryFunction)` : cette méthode te permet d'utiliser de la programmation fonctionnelle sur ta requête.

## Filtrons sur un champ

On va commencer par un filtre simple : on veut tous les trucs dont le nom contient un texte donné.

```java title="NameSomethingSpecification.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;
import lombok.RequiredArgsConstructor;
import org.springframework.data.jpa.domain.Specification;

@RequiredArgsConstructor
public class NameSomethingSpecification implements Specification<SomethingEntity> {
  private final String name;

  /**
   * On implémente la méthode {@link Specification#toPredicate} qui permet de construire la requête SQL.
   *
   * @param root            représente l'entité sur laquelle on fait la requête, la table SQL
   * @param query           représente la requête SQL
   * @param criteriaBuilder l'objet qui permet de construire la requête
   * @return un {@link Predicate} qui représente la condition de la requête
   */
  @Override
  public Predicate toPredicate(Root<SomethingEntity> root, CriteriaQuery<?> query, CriteriaBuilder criteriaBuilder) {
    return criteriaBuilder.like(root.get("name"), "%" + name + "%"); // les % sont des jokers qui permettent de dire que le texte peut être n'importe quoi, comme en SQL
  }
}
```

:::warning Attention aux Chocabugs© !

Les Specifications opérent sur les entités JPA, donc elles doivent être utilisées avec des entités qui sont gérées par JPA. Si tu utilises des champs qui ne sont pas dans l'entité, tu risques d'avoir des erreurs à l'exécution.  

Le nom utilisé dans le `root.get()` doit correspondre au nom du champ dans l'entité JPA.

SI tu mets le nom de la colonne SQL, ça plantera à l'exécution. 

_Et paf, ça fait des Chocabugs©._

:::

L'équivalent en SQL de cette requête est `SELECT * FROM something WHERE name LIKE '%texte%'`.

Ajoutons un test dans notre classe de test avec la méthode `testNamedSpecification` :

```java title="TestSpecification.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.stream.IntStream;

@Component
@Slf4j // Utilisation de Lombok pour générer les logs
@RequiredArgsConstructor
public class TestSpecification {

  private final DataGenerator dataGenerator;
  private final SomethingRepository repository;

  // ... (le reste de la classe)

  /**
   * Test de {@link NameSomethingSpecification}.
   */
  public void testNamedSpecification() {
    log.info("**** NameSomethingSpecification ****");

    NameSomethingSpecification specification = new NameSomethingSpecification("de");
    log.info("Name contains 'de' exists? {}", repository.exists(specification));
    log.info("Name contains 'de' count? {}", repository.count(specification));
    log.info("Name contains 'de' findAll? {}", repository.findAll(specification));
    repository.findOne(specification)
      .ifPresent(something -> log.info("Named contains 'de' findOne ?{}", something));
  }
}
```

N'oublie pas d'appeler cette méthode dans `BeginSpringApplication.java` pour que le test soit exécuté au démarrage de l'application.

```java title="BeginSpringApplication.java"
package fr.digicrafters.dev.sensei.blog.begin.spring;

import fr.digicrafters.dev.sensei.blog.begin.spring.specifications.TestSpecification;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BeginSpringApplication {

  public static void main(String[] args) {
    var context =SpringApplication.run(BeginSpringApplication.class, args);

    TestSpecification testSpecification = context.getBean(TestSpecification.class); // on récupère le Bean TestSpecification
    testSpecification.init(); // on initialise les données

    testSpecification.testNamedSpecification(); // on teste la spécification des noms
  }

}
```

Lance ton serveur et regarde la console. Tu devrais voir que tu as des résultats.

Si tu as mis la même `seed` que moi dans `DataGenerator`, tu devrais avoir ces résultats :
```text title="Log"
*** Test de la spécification ***
Name contains 'de' exists? true
Named contains 'de' count? 1
Named contains 'de' findAll? [SomethingEntity(id=85, name=cqwabdexmj, description=dmznzknytarmmmxwpaxx, quantity=5, insertionDate=2024-06-13T21:23:21.033847Z, liked=true)]
Named contains 'de' findOne ?SomethingEntity(id=85, name=cqwabdexmj, description=dmznzknytarmmmxwpaxx, quantity=5, insertionDate=2024-06-13T21:23:21.033847Z, liked=true)
```
Et voilà ça marche ! Tu as réussi à filtrer sur un champ. 

Bon, on est d'accord, tu n'avais pas besoin de `Specifications` pour ça. Tu pouvais utiliser des [JPA Query Methods](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html) directement dans ton repository. Mais ce n'est que l'échauffement, les Specifications sont bien plus puissantes.


:::info L'astuce de ton dev sensei
Cette méthode `findAll` fait la même chose que notre `NameSomethingSpecification` :

```java title="SomethingRepository.java" 
List<SomethingEntity> findAllByNameContaining(String name);
```

Je ferai certainement un article sur les JPA Query Methods, car elles sont très pratiques et permettent de faire beaucoup de choses sans avoir à écrire de code. Mais pour l'instant, restons concentrés sur les Specifications.
:::

## Filtrons sur un champ _ou_ un autre


Bien, faisons un filtre général pour ça : on met un texte en entrée et on veut tous les trucs qui contiennent ce texte dans leur nom ou leur description. 
  
```java title="NameOrDescriptionSomethingSpecification.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;
import lombok.RequiredArgsConstructor;
import org.springframework.data.jpa.domain.Specification;

@RequiredArgsConstructor
public class NameOrDescriptionSomethingSpecification implements Specification<SomethingEntity> {
  private final String text;

 
  @Override
  public Predicate toPredicate(Root<SomethingEntity> root, CriteriaQuery<?> query, CriteriaBuilder criteriaBuilder) {
    // On crée une condition qui vérifie si le nom ou la description contient le texte recherché
    Predicate namePredicate = criteriaBuilder.like(root.get("name"), "%" + text + "%");
    Predicate descriptionPredicate = criteriaBuilder.like(root.get("description"), "%" + text + "%");
    // On combine les deux conditions avec un OR
    return criteriaBuilder.or(namePredicate, descriptionPredicate);
  }
}
```

Et on ajoute un test dans notre classe de test :

```java title="TestSpecification.java"
package fr.digicrafters.dev.sensei.blog.begin.spring.specifications;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.stream.IntStream;

@Component
@Slf4j // Utilisation de Lombok pour générer les logs
@RequiredArgsConstructor
public class TestSpecification {

  private final DataGenerator dataGenerator;
  private final SomethingRepository repository;

  // ... (le reste de la classe)

  /**
   * Test de {@link NameOrDescriptionSomethingSpecification}.
   */
  public void testNameOrDescriptionSomethingSpecification() {
    log.info("**** NameOrDescriptionSomethingSpecification ****");

    NameOrDescriptionSomethingSpecification nameContainsC = new NameOrDescriptionSomethingSpecification("de");
    log.info("Name or description contain 'de' exists? {}", repository.exists(nameContainsC));
    log.info("Name or description contain 'de' count? {}", repository.count(nameContainsC));
    log.info("Name or description contain 'de' findAll? {}", repository.findAll(nameContainsC));
    // Pas de findOne car il y a plusieurs résultats
  }
}
```

Comme la précédente, n'oublie pas de l'appeler dans `BeginSpringApplication.java` :

```java title="BeginSpringApplication.java"
package fr.digicrafters.dev.sensei.blog.begin.spring;

import fr.digicrafters.dev.sensei.blog.begin.spring.specifications.TestSpecification;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BeginSpringApplication {

	public static void main(String[] args) {
		var context =SpringApplication.run(BeginSpringApplication.class, args);

		TestSpecification testSpecification = context.getBean(TestSpecification.class); // on récupère le Bean TestSpecification
		testSpecification.init(); // on initialise les données

		testSpecification.testNamedSpecification(); // on teste la spécification des noms
		testSpecification.testNameOrDescriptionSomethingSpecification(); // on teste la spécification des noms
	}
}

```

Lance ton serveur et regarde la console. Tu devrais voir que tu as des résultats.
Si tu as mis la même `seed` que moi dans `DataGenerator`, tu devrais avoir ces résultats :
```text title="Log"
**** NameOrDescriptionSomethingSpecification ****
Name or description contain 'de' exists? true                                          
Name or description contain 'de' count? 3
Name or description contain 'de' findAll? [SomethingEntity(id=44, name=cieqrminxi, description=qdefqntezpkjtcqbvnwf, quantity=5, insertionDate=2025-06-26T11:50:01.750857Z, liked=false), SomethingEntity(id=62, name=hwobxxjqxn, description=rnaowqcsrgvrdeeajdpq, quantity=6, insertionDate=2025-06-26T11:50:01.770950Z, liked=false), SomethingEntity(id=85, name=cqwabdexmj, description=dmznzknytarmmmxwpaxx, quantity=5, insertionDate=2025-06-26T11:50:01.797754Z, liked=true)] 
```

Encore bravo, tu as réussi à filtrer sur deux champs en même temps !

